# Backend ‚Äì Webtech-2025 API

Node.js + Express + Prisma Backend f√ºr das Infoletter Management System.

---

## üèóÔ∏è Architektur

```
backend/
‚îú‚îÄ‚îÄ prisma/
‚îÇ   ‚îú‚îÄ‚îÄ schema.prisma      # Datenbank-Schema (Type-Safe)
‚îÇ   ‚îî‚îÄ‚îÄ migrations/        # Datenbank-Migrationen
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ config/            # Konfiguration (DB, Environment)
‚îÇ   ‚îú‚îÄ‚îÄ controllers/       # Request-Handler (Express Middleware)
‚îÇ   ‚îú‚îÄ‚îÄ middleware/        # Auth, Error-Handling, Validation
‚îÇ   ‚îú‚îÄ‚îÄ routes/            # API-Routen Definition
‚îÇ   ‚îú‚îÄ‚îÄ services/          # Business-Logik (getrennt von Controller)
‚îÇ   ‚îú‚îÄ‚îÄ utils/             # Hilfsfunktionen (JWT, Password, Validation)
‚îÇ   ‚îú‚îÄ‚îÄ types/             # TypeScript Type Definitions
‚îÇ   ‚îú‚îÄ‚îÄ app.ts             # Express App Setup
‚îÇ   ‚îî‚îÄ‚îÄ server.ts          # Server Entry Point
‚îú‚îÄ‚îÄ tests/              # API-Tests (REST Client)
‚îú‚îÄ‚îÄ uploads/            # Hochgeladene Dateien (gitignored)
‚îú‚îÄ‚îÄ .env                # Environment Variables (gitignored)
‚îú‚îÄ‚îÄ .env.example        # Template f√ºr .env
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ tsconfig.json
```

---

## üöÄ Installation & Setup

Siehe [Haupt-README](../README.md) f√ºr vollst√§ndige Installationsanleitung.

### Schnellstart

```bash
# Dependencies installieren
npm install

# .env erstellen
cp .env.example .env

# Datenbank migrieren
npx prisma migrate dev

# Prisma Client generieren
npx prisma generate

# Development Server starten (Hot Reload)
npm run dev
```

‚úÖ Backend l√§uft auf http://localhost:3001

---

## üõ†Ô∏è Technologie-Stack & Warum?

### **Node.js + Express**
> **Warum Express?** Minimalistisches, aber m√§chtiges JavaScript-Framework. Gro√üe Ecosystem. TypeScript-Support. Ideal f√ºr RESTful APIs. Schnelle Entwicklung mit Middleware-Pattern.

```typescript
// ‚úÖ Express App Setup (src/app.ts)
const app = express()

// Middleware Stack
app.use(express.json())  // JSON Parsing
app.use(cors())          // CORS f√ºr Frontend
app.use(authMiddleware)  // JWT Auth
app.use(errorMiddleware) // Error Handling

// Routes
app.use('/api/auth', authRoutes)
app.use('/api/infoletters', infolletterRoutes)
```

### **TypeScript**
> **Warum TypeScript?** Type Safety f√ºr Backend-Code. Compile-time Error Detection. Auto-completion. Refactoring-sicher. API-Contracts sind dokumentiert.

```typescript
// ‚úÖ Type-Safe Routes
router.post('/login', async (req: Request, res: Response) => {
  const { email, password }: LoginRequest = req.body
  const response: LoginResponse = await authService.login(...)
  res.json(response)
})
```

### **Prisma ORM**
> **Warum Prisma?** Type-safe Database Access. Auto-generated TypeScript Types aus Schema. Einfache Migrations. SQL-Injection Prevention. Bessere Dev Experience.

```prisma
// ‚úÖ prisma/schema.prisma - Schema Definition
model User {
  id    String  @id @default(cuid())
  email String  @unique
  password String
  name  String
  role  Role    @default(USER)
  
  // Relations
  infoletters Infoletter[]
  collaborations InfoletterCollaborator[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Infoletter {
  id        String  @id @default(cuid())
  title     String
  content   String
  status    Status  @default(DRAFT)  // DRAFT | PUBLISHED
  
  owner   User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId String
  
  collaborators InfoletterCollaborator[]
  versions InfoletterVersion[]
  images   InfoletterImage[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

**Benefits:**
```typescript
// ‚úÖ Type-generated by Prisma
type User = {
  id: string
  email: string
  password: string
  // ... alle Felder mit Typen!
}

// ‚úÖ Safe Queries
const user = await prisma.user.findUnique({
  where: { email }
})
// ‚Üí TypeScript wei√ü: user is User | null
```

### **PostgreSQL Datenbank**
> **Warum PostgreSQL?** Production-ready, ACID-compliant. St√ºrbare Queries. Bessere Performance bei komplexeren Daten. Open-Source, kostenlos. JSON-Support.

```typescript
// ‚úÖ Connection String
DATABASE_URL="postgresql://user:password@localhost:5432/webtech_db"

// ‚úÖ Connection Pooling durch Prisma
// Automatisches Verwalten von DB-Connections
```

### **JWT Authentication**
> **Warum JWT?** Stateless Authentication. Keine Session-Datenbank n√∂tig. Skalierbar √ºber Multiple Servers. Refresh-Token Pattern f√ºr Security.

```typescript
// ‚úÖ JWT Token Structure
{
  accessToken: "eyJhbGc...",   // Kurze G√ºltigkeit (1h)
  refreshToken: "eyJhbGc...",  // Lange G√ºltigkeit (7d)
  expiresIn: 3600
}

// ‚úÖ Token Verification Middleware
const authMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers.authorization?.split(' ')[1]
  if (!token) return res.status(401).json({ error: 'No token' })
  
  try {
    const payload = jwt.verify(token, JWT_SECRET)
    req.user = payload  // Attached to request
    next()
  } catch (err) {
    res.status(401).json({ error: 'Invalid token' })
  }
}
```

### **Bcrypt Password Hashing**
> **Warum Bcrypt?** Slow, Adaptive Hashing-Algorithm. Salt-Generierung automatisch. GPU-resistant. Industry Standard f√ºr Password Storage.

```typescript
// ‚úÖ Password Hashing
const hashedPassword = await bcrypt.hash(password, 10)  // 10 salt rounds

// ‚úÖ Password Verification
const isValid = await bcrypt.compare(plainPassword, hashedPassword)
```

### **Zod Schema Validation**
> **Warum Zod?** Runtime Type-Checking. TypeScript-First. Bessere Error-Messages. Automatisches Parsing (z.B. String zu Number).

```typescript
// ‚úÖ Schema Definition
const loginSchema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string().min(8, 'Min 8 chars')
})

// ‚úÖ Automatic Validation
router.post('/login', (req, res) => {
  const result = loginSchema.safeParse(req.body)
  
  if (!result.success) {
    return res.status(400).json({ errors: result.error.format() })
  }
  
  // result.data ist garantiert valide!
  const { email, password } = result.data
})
```

---

## üîå API-Endpunkte

### **Authentifizierung** (`/api/auth`)

| Methode | Endpunkt | Beschreibung | Auth |
|---------|----------|--------------|------|
| POST | `/register` | Benutzer registrieren | ‚ùå |
| POST | `/login` | Einloggen | ‚ùå |
| POST | `/logout` | Ausloggen | ‚úÖ |
| POST | `/refresh` | Access Token erneuern | ‚ùå (Refresh Token) |
| GET | `/me` | Eigenes Profil abrufen | ‚úÖ |
| POST | `/forgot-password` | Passwort-Reset anfordern | ‚ùå |
| POST | `/reset-password/:token` | Passwort zur√ºcksetzen | ‚ùå |

### **Benutzer** (`/api/users`) üöß

| Methode | Endpunkt | Beschreibung | Auth |
|---------|----------|--------------|------|
| GET | `/me` | Eigenes Profil | ‚úÖ |
| PUT | `/me` | Profil bearbeiten | ‚úÖ |
| POST | `/me/profile-image` | Profilbild hochladen | ‚úÖ |
| DELETE | `/me` | Konto l√∂schen | ‚úÖ |
| GET | `/` | Alle Benutzer (Admin) | ‚úÖ Admin |

### **Infoletters** (`/api/infoletters`) üöß

| Methode | Endpunkt | Beschreibung | Auth |
|---------|----------|--------------|------|
| GET | `/` | Alle Infoletters | ‚úÖ |
| POST | `/` | Neuen Infoletter erstellen | ‚úÖ |
| GET | `/:id` | Infoletter abrufen | ‚úÖ |
| PUT | `/:id` | Infoletter bearbeiten | ‚úÖ (Owner/Co-Author) |
| DELETE | `/:id` | Infoletter l√∂schen | ‚úÖ (Owner) |
| PATCH | `/:id/publish` | Infoletter ver√∂ffentlichen | ‚úÖ (Owner) |

### **Collaborators** (`/api/infoletters/:id/collaborators`) üöß

| Methode | Endpunkt | Beschreibung | Auth |
|---------|----------|--------------|------|
| GET | `/` | Collaborators auflisten | ‚úÖ |
| POST | `/` | Collaborator hinzuf√ºgen | ‚úÖ (Owner) |
| DELETE | `/:userId` | Collaborator entfernen | ‚úÖ (Owner) |

---

## üë§ Controller vs Service Pattern

### **Controller** - RequestHandler
```typescript
// src/controllers/authController.ts
export const login = async (req: Request, res: Response) => {
  try {
    // üë§ Express stuff
    const { email, password } = req.body
    
    // üë§ Call Service
    const result = await authService.login(email, password)
    
    // üë§ Response
    res.json(result)
  } catch (err) {
    res.status(400).json({ error: err.message })
  }
}
```

### **Service** - Business Logic
```typescript
// src/services/authService.ts
export const authService = {
  async login(email: string, password: string) {
    // üëë Business Logic hier!
    const user = await prisma.user.findUnique({ where: { email } })
    if (!user) throw new Error('User not found')
    
    const isValid = await bcrypt.compare(password, user.password)
    if (!isValid) throw new Error('Invalid password')
    
    // üëë Generate JWT Tokens
    const accessToken = jwt.sign({ sub: user.id }, JWT_SECRET, { expiresIn: '1h' })
    const refreshToken = jwt.sign({ sub: user.id }, JWT_SECRET, { expiresIn: '7d' })
    
    return { user, accessToken, refreshToken }
  }
}
```

**Warum getrennt?**
- ‚úÖ Testbar (Service ohne Express)
- ‚úÖ Wiederverwendbar (mehrere Controller k√∂nnen Service verwenden)
- ‚úÖ Wartbar (klare Separation of Concerns)

---

## üìÑ Middleware Stack

```typescript
// src/app.ts
const app = express()

// 1Ô∏è‚É£ JSON Parsing
app.use(express.json())

// 2Ô∏è‚É£ CORS - Nur localhost:5173 (Frontend)
app.use(cors({
  origin: 'http://localhost:5173',
  credentials: true
}))

// 3Ô∏è‚É£ Logging Middleware
app.use((req, res, next) => {
  console.log(`${req.method} ${req.path}`)
  next()
})

// 4Ô∏è‚É£ Auth Middleware (protected routes)
app.use('/api/protected', authMiddleware)

// 5Ô∏è‚É£ Routes
app.use('/api/auth', authRoutes)
app.use('/api/infoletters', infolletterRoutes)

// 6Ô∏è‚É£ Error Handler (muss am Ende!)
app.use(errorHandler)
```

---

## üß™ Development Best Practices

### **1. Async/Await mit Error Handling**

```typescript
// ‚úÖ Immer try-catch
router.get('/users/:id', async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.params.id }
    })
    if (!user) return res.status(404).json({ error: 'Not found' })
    res.json(user)
  } catch (err) {
    res.status(500).json({ error: 'Server error' })
  }
})
```

### **2. Validation mit Zod**

```typescript
// ‚úÖ Schema Definition
const createInfoletterSchema = z.object({
  title: z.string().min(3).max(100),
  content: z.string(),
  status: z.enum(['DRAFT', 'PUBLISHED'])
})

// ‚úÖ In Route
router.post('/', (req, res) => {
  const parsed = createInfoletterSchema.safeParse(req.body)
  if (!parsed.success) {
    return res.status(400).json({ errors: parsed.error.flatten() })
  }
  // parsed.data ist valide
})
```

### **3. Prisma Query Patterns**

```typescript
// ‚úÖ Include Relations
const infoletter = await prisma.infoletter.findUnique({
  where: { id },
  include: {
    owner: true,
    collaborators: true,
    images: true
  }
})

// ‚úÖ Select specific fields
const users = await prisma.user.findMany({
  select: { id: true, email: true }  // Nur diese Felder
})

// ‚úÖ Pagination
const infoletters = await prisma.infoletter.findMany({
  skip: (page - 1) * pageSize,
  take: pageSize,
  orderBy: { createdAt: 'desc' }
})
```

---

## üë£ Environment Variables

Siehe `.env.example` f√ºr alle verf√ºgbaren Variablen.

```env
# Database
DATABASE_URL="postgresql://postgres:password@localhost:5432/webtech_db"

# JWT
JWT_SECRET="mindestens-32-zeichen-zufaelliger-string"
JWT_REFRESH_SECRET="anderer-secret"

# Server
PORT=3001
NODE_ENV=development
BASE_URL=http://localhost:3001

# CORS
CORS_ORIGIN=http://localhost:5173

# Optional: Email Service
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-password
```

---

## üìÑ Datenbank-Schema Highlights

### **Soft Deletes**
```prisma
model User {
  id        String  @id @default(cuid())
  // ...
  deletedAt DateTime?  // NULL = nicht gel√∂scht
}

// üë§ Nur aktive User abrufen
await prisma.user.findMany({
  where: { deletedAt: null }
})
```

### **Relations**
```prisma
model Infoletter {
  id      String
  owner   User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId String
}

// üë§ Automatisch mit Owner laden
const infoletter = await prisma.infoletter.findUnique({
  where: { id },
  include: { owner: true }  // User wird mitgeladen!
})
```

### **Indexes f√ºr Performance**
```prisma
model User {
  email String @unique  // Automatischer Index
  @@index([createdAt])   // Expliziter Index
}
```

---

## üêõ Troubleshooting

### Prisma Client not generated
```bash
npx prisma generate
```

### Migration failed
```bash
# ACHTUNG: L√∂scht alle Daten!
npx prisma migrate reset
```

### Prisma Studio √∂ffnen
```bash
npx prisma studio
```

Zugriff auf visuelle Datenbank auf http://localhost:5555

### Port bereits belegt
```env
PORT=3002
```

### TypeScript Fehler
```bash
rm -rf node_modules
npm install
npm run build
```

---

## üìñ Weitere Ressourcen

- [Prisma Dokumentation](https://www.prisma.io/docs/)
- [Express Best Practices](https://expressjs.com/en/advanced/best-practice-security.html)
- [JWT.io](https://jwt.io/)
- [Zod Validation](https://zod.dev/)
- [PostgreSQL Docs](https://www.postgresql.org/docs/)
- [Hauptprojekt README](../README.md)

---

## üõ†Ô∏è Scripts

```bash
# Development
npm run dev          # Start mit Hot-Reload (tsx watch)

# Build
npm run build        # TypeScript kompilieren
npm start            # Production Server starten

# Prisma
npm run prisma:generate   # Prisma Client generieren
npm run prisma:migrate    # Neue Migration erstellen
npm run prisma:studio     # Prisma Studio √∂ffnen

# Tests
npm test            # Jest Tests ausf√ºhren
npm run test:watch  # Watch Mode
```

---

**Happy Coding! üöÄ**
